#!/usr/bin/env python3
"""
Parse Graphviz .dot files to JSON format

Converts computation graph .dot files (generated by llama.cpp) into JSON
format suitable for the WebUI visualization tool.

Usage:
    python parse_dot.py --dot /tmp/graphs/token_00001.dot --output data/graphs/token-00001.json
"""

import argparse
import json
import re
import os
from typing import List, Dict, Any, Tuple


def extract_layer_id(tensor_name: str) -> int:
    """
    Extract layer ID from tensor name.

    Args:
        tensor_name: Tensor name (e.g., "Qcur-0", "blk.5.attn_q", "ffn_inp-12")

    Returns:
        Layer ID (0-N), or None for non-layer tensors
    """
    # Pattern 1: "name-N" format (e.g., "Qcur-0", "ffn_inp-12")
    match = re.search(r'-(\d+)(?:\s|$|\)|,)', tensor_name)
    if match:
        return int(match.group(1))

    # Pattern 2: "blk.N." format (e.g., "blk.5.attn_q")
    match = re.search(r'blk\.(\d+)\.', tensor_name)
    if match:
        return int(match.group(1))

    # Pattern 3: "l_out-N", "attn_out-N", etc.
    match = re.search(r'_(\d+)(?:\s|$|\))', tensor_name)
    if match:
        return int(match.group(1))

    return None


def categorize_tensor(tensor_name: str, operation: str) -> str:
    """
    Categorize tensor by its purpose.

    Args:
        tensor_name: Tensor name
        operation: Operation type

    Returns:
        Category: "input", "attention", "ffn", "norm", "output", "other"
    """
    name_lower = tensor_name.lower()

    if "inp_embd" in name_lower or "get_rows" in operation.lower():
        return "input"
    elif any(x in name_lower for x in ["qcur", "kcur", "vcur", "attn", "kqv", "fattn"]):
        return "attention"
    elif any(x in name_lower for x in ["ffn", "mlp", "gate", "swiglu"]):
        return "ffn"
    elif "norm" in name_lower:
        return "norm"
    elif "output" in name_lower or "logits" in name_lower:
        return "output"
    else:
        return "other"


def parse_node_label(label: str) -> Tuple[str, str, List[int], str]:
    """
    Parse node label from .dot file.

    Label format: "name (dtype)|node_num [shape] | <x>operation"

    Args:
        label: Label string

    Returns:
        Tuple of (name, dtype, shape, operation)
    """
    # Split by "|"
    parts = label.split('|')
    if len(parts) < 3:
        # Malformed label, return defaults
        return label, "unknown", [], "unknown"

    # Part 1: "name (dtype)"
    name_part = parts[0].strip()
    name_match = re.match(r'(.+?)\s*\(([^)]+)\)', name_part)
    if name_match:
        name = name_match.group(1).strip()
        dtype = name_match.group(2).strip()
    else:
        name = name_part
        dtype = "unknown"

    # Part 2: "node_num [shape]"
    shape_part = parts[1].strip()
    shape_match = re.search(r'\[([^\]]+)\]', shape_part)
    if shape_match:
        shape_str = shape_match.group(1)
        # Parse shape: "2048, 14" -> [2048, 14]
        try:
            shape = [int(x.strip()) for x in shape_str.split(',')]
        except ValueError:
            shape = []
    else:
        shape = []

    # Part 3: "<x>operation"
    op_part = parts[2].strip()
    # Remove "<x>" prefix and any trailing whitespace
    operation = re.sub(r'<[^>]+>', '', op_part).strip()

    return name, dtype, shape, operation


def parse_dot_file(dot_path: str) -> Dict[str, Any]:
    """
    Parse .dot file and extract graph structure.

    Args:
        dot_path: Path to .dot file

    Returns:
        Dictionary containing graph data
    """
    nodes = []
    edges = []
    node_counter = 0

    with open(dot_path, 'r') as f:
        for line in f:
            line = line.strip()

            # Parse node definition
            # Format: "0x15001a8c0" [ ... label="..." ]
            node_match = re.match(r'"([^"]+)"\s*\[\s*[^]]*label\s*=\s*"([^"]+)"', line)
            if node_match:
                address = node_match.group(1)
                label = node_match.group(2)

                # Parse label
                name, dtype, shape, operation = parse_node_label(label)

                # Extract layer ID
                layer_id = extract_layer_id(name)

                # Categorize
                category = categorize_tensor(name, operation)

                # Create node entry
                node = {
                    "id": f"node_{node_counter}",
                    "address": address,
                    "label": name,
                    "operation": operation,
                    "shape": shape,
                    "dtype": dtype,
                    "layer_id": layer_id,
                    "category": category
                }

                nodes.append(node)
                node_counter += 1

            # Parse edge definition
            # Format: "0x100660020" -> "0x15001a8c0" [ ... label = "src 0"; ]
            edge_match = re.match(r'"([^"]+)"\s*->\s*"([^"]+)"\s*\[\s*[^]]*label\s*=\s*"([^"]+)"', line)
            if edge_match:
                source_addr = edge_match.group(1)
                target_addr = edge_match.group(2)
                edge_label = edge_match.group(3)

                edge = {
                    "source_address": source_addr,
                    "target_address": target_addr,
                    "label": edge_label
                }

                edges.append(edge)

    return {
        "nodes": nodes,
        "edges": edges
    }


def build_address_to_id_map(nodes: List[Dict]) -> Dict[str, str]:
    """
    Build mapping from address to node ID.

    Args:
        nodes: List of node dictionaries

    Returns:
        Dictionary mapping address -> node_id
    """
    return {node["address"]: node["id"] for node in nodes}


def convert_edges_to_ids(edges: List[Dict], addr_to_id: Dict[str, str]) -> List[Dict]:
    """
    Convert edge addresses to node IDs.

    Args:
        edges: List of edge dictionaries (with addresses)
        addr_to_id: Mapping from address to node ID

    Returns:
        List of edges with node IDs instead of addresses
    """
    converted = []
    for edge in edges:
        source_id = addr_to_id.get(edge["source_address"])
        target_id = addr_to_id.get(edge["target_address"])

        # Skip edges with unknown nodes
        if source_id and target_id:
            converted.append({
                "source": source_id,
                "target": target_id,
                "label": edge["label"]
            })

    return converted


def compute_metadata(nodes: List[Dict]) -> Dict[str, Any]:
    """
    Compute metadata about the graph.

    Args:
        nodes: List of node dictionaries

    Returns:
        Metadata dictionary
    """
    # Count layers
    layer_ids = [n["layer_id"] for n in nodes if n["layer_id"] is not None]
    n_layers = max(layer_ids) + 1 if layer_ids else 0

    return {
        "total_nodes": len(nodes),
        "total_edges": 0,  # Will be updated later
        "layers": n_layers,
        "timestamp_generated": None  # Could extract from file mtime
    }


def parse_dot_to_json(dot_path: str, token_id: int = None) -> Dict[str, Any]:
    """
    Parse .dot file and convert to JSON format.

    Args:
        dot_path: Path to .dot file
        token_id: Token ID (inferred from filename if not provided)

    Returns:
        Graph data in JSON format
    """
    # Infer token ID from filename if not provided
    if token_id is None:
        # Extract from filename like "token_00001.dot"
        filename = os.path.basename(dot_path)
        match = re.search(r'token_(\d+)', filename)
        if match:
            token_id = int(match.group(1))

    # Parse .dot file
    graph_data = parse_dot_file(dot_path)

    # Build address-to-ID mapping
    addr_to_id = build_address_to_id_map(graph_data["nodes"])

    # Convert edges to use node IDs
    edges = convert_edges_to_ids(graph_data["edges"], addr_to_id)

    # Compute metadata
    metadata = compute_metadata(graph_data["nodes"])
    metadata["total_edges"] = len(edges)

    # Build final JSON structure
    result = {
        "token_id": token_id,
        "metadata": metadata,
        "nodes": graph_data["nodes"],
        "edges": edges
    }

    return result


def main():
    parser = argparse.ArgumentParser(
        description='Parse Graphviz .dot file to JSON'
    )
    parser.add_argument(
        '--dot',
        required=True,
        help='Path to .dot file (e.g., /tmp/graphs/token_00001.dot)'
    )
    parser.add_argument(
        '--output',
        required=True,
        help='Path to output JSON file (e.g., data/graphs/token-00001.json)'
    )
    parser.add_argument(
        '--token-id',
        type=int,
        help='Token ID (optional, inferred from filename if not provided)'
    )
    parser.add_argument(
        '--pretty',
        action='store_true',
        help='Pretty-print JSON output'
    )

    args = parser.parse_args()

    # Parse .dot file
    print(f"Reading .dot file: {args.dot}")
    graph_json = parse_dot_to_json(args.dot, args.token_id)

    print(f"Parsed {graph_json['metadata']['total_nodes']} nodes")
    print(f"Parsed {graph_json['metadata']['total_edges']} edges")
    print(f"Layers: {graph_json['metadata']['layers']}")

    # Create output directory if needed
    output_dir = os.path.dirname(args.output)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
        print(f"Created directory: {output_dir}")

    # Write JSON
    indent = 2 if args.pretty else None
    with open(args.output, 'w') as f:
        json.dump(graph_json, f, indent=indent)

    print(f"âœ“ Graph data written to: {args.output}")
    print(f"  File size: {os.path.getsize(args.output) / 1024:.1f} KB")


if __name__ == '__main__':
    main()
