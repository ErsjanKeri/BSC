/**
 * Type definitions for tensor tracing data structures
 *
 * These types match the JSON format generated by our preprocessing scripts:
 * - parse_csv.py → memory-map.json
 * - parse_dot.py → graph-token-NNNNN.json
 * - parse_trace.py → trace-token-NNNNN.json
 */

// ============================================================================
// Graph Data (from parse_dot.py)
// ============================================================================

export interface GraphNode {
  id: string                  // "node_0", "node_1", ...
  address: string             // "0x15001a8c0" (CORRELATION KEY)
  label: string               // Tensor name: "inp_embd", "Qcur-0", "blk.0.attn_q"
  operation: string           // Operation: "GET_ROWS", "MUL_MAT", "ROPE", "ADD"
  shape: number[]             // Tensor shape: [2048, 14], [1, 1, 2048, 14]
  dtype: string               // Data type: "f32", "f16", "q4_k", "q8_0"
  layer_id: number | null     // Layer ID: 0-21, or null for non-layer tensors
  category: string            // "input" | "attention" | "ffn" | "norm" | "output" | "other"
}

export interface GraphEdge {
  source: string              // Source node ID: "node_0"
  target: string              // Target node ID: "node_5"
  label: string               // Edge label: "src 0", "src 1"
}

export interface GraphMetadata {
  total_nodes: number         // Total number of nodes in graph
  total_edges: number         // Total number of edges
  layers: number              // Number of transformer layers
  timestamp_generated: string | null
}

export interface GraphData {
  token_id: number | null     // Token ID this graph represents
  metadata: GraphMetadata
  nodes: GraphNode[]
  edges: GraphEdge[]
}

// ============================================================================
// Trace Data (from parse_trace.py)
// ============================================================================

export interface TraceEntry {
  entry_id: number                 // Sequential entry number
  timestamp_ns: number             // Absolute timestamp (nanoseconds)
  timestamp_relative_ms: number    // Relative to first entry (milliseconds)

  // Execution context
  token_id: number                 // Token ID being processed
  layer_id: number                 // Layer ID (65535 = N/A)
  thread_id: number                // Thread that executed this operation
  phase: string                    // "PROMPT" | "GENERATE"

  // Operation
  operation_type: string           // "MUL_MAT", "ADD", "ROPE", etc.

  // Tensor identification (CORRELATION KEYS)
  tensor_idx: number | null        // Tensor index in registry (null if not found)
  tensor_ptr: string               // Memory address: "0x15001a8c0"
  tensor_name: string              // Tensor name: "blk.0.attn_q.weight"
  size_bytes: number               // Size of tensor in bytes
  file_offset: number              // Offset in GGUF file
}

export interface TraceMetadata {
  total_entries: number            // Number of trace entries
  duration_ms: number              // Total execution time
  timestamp_start_ns: number       // First timestamp
}

export interface TraceData {
  token_id: number | null          // Token ID
  metadata: TraceMetadata
  entries: TraceEntry[]
}

// ============================================================================
// Memory Map (from parse_csv.py)
// ============================================================================

export interface MemoryTensor {
  name: string                     // Full tensor name
  offset_start: number             // Byte offset in GGUF file (start)
  offset_end: number               // Byte offset in GGUF file (end)
  size_bytes: number               // Size in bytes
  shape: number[]                  // Tensor dimensions
  dtype: string                    // Data type
  category: string                 // "embedding" | "attention" | "ffn" | "norm" | "output"
  layer_id: number | null          // Layer ID or null
  component_type: string           // Original component type from CSV
  component: string                // Component name: "query", "key", "value", etc.
}

export interface MemoryMapMetadata {
  n_layers: number                 // Number of transformer layers
  n_vocab: number                  // Vocabulary size
  n_embd: number                   // Embedding dimension
  n_heads?: number                 // Number of attention heads (optional)
}

export interface MemoryMap {
  model_name: string               // Model name (e.g., "tinyllama")
  total_size_bytes: number         // Total model size
  metadata: MemoryMapMetadata
  tensors: MemoryTensor[]
}

// ============================================================================
// UI State Types
// ============================================================================

export interface SelectedNode {
  nodeId: string
  address: string
  label: string
  layer_id: number | null
}

export interface SelectedTrace {
  entryId: number
  timestamp_relative_ms: number
  tensor_ptr: string
}

export interface TimelineState {
  currentTime: number              // Current position in timeline (ms)
  isPlaying: boolean               // Animation playing
  playbackSpeed: number            // Speed multiplier: 0.5x, 1x, 2x, 4x
}

export interface FilterState {
  selectedLayer: number | null     // Filter by layer (null = all)
  selectedCategory: string | null  // Filter by category (null = all)
  searchTerm: string               // Text search filter
}

// ============================================================================
// Correlation Index Types
// ============================================================================

export interface CorrelationIndex {
  // Address → Node mapping (for graph highlighting from trace)
  addressToNode: Map<string, GraphNode>

  // Address → Trace entries (all accesses to this tensor)
  addressToTraces: Map<string, TraceEntry[]>

  // Node ID → Memory tensor (for memory heatmap)
  nodeToMemory: Map<string, MemoryTensor>

  // Layer ID → Nodes in that layer
  layerToNodes: Map<number, GraphNode[]>

  // Time → Active nodes (for timeline animation)
  timeIndex: {
    timestamps: number[]           // Sorted timestamps (ms)
    activeNodes: string[][]        // Active node IDs at each timestamp
  }
}
