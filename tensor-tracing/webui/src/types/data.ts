/**
 * Type definitions for tensor tracing data structures
 *
 * These types match the JSON format generated by our preprocessing scripts:
 * - parse_csv.py → memory-map.json
 * - parse_dot.py → graph-token-NNNNN.json
 * - parse_trace.py → trace-token-NNNNN.json
 */

// ============================================================================
// Graph Data (from parse_dot.py)
// ============================================================================

export interface GraphNode {
  id: string                  // "node_0", "node_1", ...
  address: string             // "0x15001a8c0" (CORRELATION KEY)
  label: string               // Tensor name: "inp_embd", "Qcur-0", "blk.0.attn_q"
  operation: string           // Operation: "GET_ROWS", "MUL_MAT", "ROPE", "ADD"
  shape: number[]             // Tensor shape: [2048, 14], [1, 1, 2048, 14]
  dtype: string               // Data type: "f32", "f16", "q4_k", "q8_0"
  layer_id: number | null     // Layer ID: 0-21, or null for non-layer tensors
  category: string            // "input" | "attention" | "ffn" | "norm" | "output" | "other"
}

export interface GraphEdge {
  source: string              // Source node ID: "node_0"
  target: string              // Target node ID: "node_5"
  label: string               // Edge label: "src 0", "src 1"
}

export interface GraphMetadata {
  total_nodes: number         // Total number of nodes in graph
  total_edges: number         // Total number of edges
  layers: number              // Number of transformer layers
  timestamp_generated: string | null
}

export interface GraphData {
  token_id: number | null     // Token ID this graph represents
  metadata: GraphMetadata
  nodes: GraphNode[]
  edges: GraphEdge[]
}

// ============================================================================
// Trace Data (from parse_trace.py) - NEW 256-byte format
// ============================================================================

export interface SourceTensorInfo {
  name: string                     // Source tensor name (may be truncated to 20 chars)
  tensor_ptr: string               // Memory address: "0x15001a8c0"
  size_bytes: number               // Size of tensor in bytes
  layer_id: number | null          // Layer ID or null
  memory_source: "DISK" | "BUFFER" // Memory source type (NEW!)
  disk_offset?: number             // If DISK: offset in GGUF file
  buffer_id?: number               // If BUFFER: buffer identifier
  tensor_idx?: number | null       // Tensor index in registry (optional)
}

export interface TraceEntry {
  entry_id: number                 // Sequential entry number
  timestamp_ns: number             // Absolute timestamp (nanoseconds)
  timestamp_relative_ms: number    // Relative to first entry (milliseconds)

  // Execution context
  token_id: number                 // Token ID being processed
  layer_id: number | null          // Layer ID or null (was 65535 for N/A, now null)
  thread_id: number                // Thread that executed this operation
  phase: string                    // "PROMPT" | "GENERATE"

  // Operation (NEW: all operations, not just MUL_MAT)
  operation_type: string           // "MUL_MAT", "ADD", "ROPE", "OUT_PROD", "LOG", etc.

  // Destination tensor (NEW!)
  dst_name: string                 // Destination tensor name

  // Source tensors (NEW: multi-source structure)
  num_sources: number              // Number of source tensors (0-4)
  sources: SourceTensorInfo[]      // Array of source tensors
}

export interface TraceMetadata {
  total_entries: number            // Number of trace entries
  duration_ms: number              // Total execution time
  timestamp_start_ns: number       // First timestamp
  format_version: string           // Format version: "256-byte"
}

export interface TraceData {
  token_id: number | null          // Token ID
  metadata: TraceMetadata
  entries: TraceEntry[]
}

// ============================================================================
// Memory Map (from parse_csv.py)
// ============================================================================

export interface MemoryTensor {
  name: string                     // Full tensor name
  offset_start: number             // Byte offset in GGUF file (start)
  offset_end: number               // Byte offset in GGUF file (end)
  size_bytes: number               // Size in bytes
  shape: number[]                  // Tensor dimensions
  dtype: string                    // Data type
  category: string                 // "embedding" | "attention" | "ffn" | "norm" | "output"
  layer_id: number | null          // Layer ID or null
  component_type: string           // Original component type from CSV
  component: string                // Component name: "query", "key", "value", etc.
}

export interface MemoryMapMetadata {
  n_layers: number                 // Number of transformer layers
  n_vocab: number                  // Vocabulary size
  n_embd: number                   // Embedding dimension
  n_heads?: number                 // Number of attention heads (optional)
}

export interface MemoryMap {
  model_name: string               // Model name (e.g., "tinyllama")
  total_size_bytes: number         // Total model size
  metadata: MemoryMapMetadata
  tensors: MemoryTensor[]
}

// ============================================================================
// UI State Types
// ============================================================================

export interface SelectedNode {
  nodeId: string
  address: string
  label: string
  layer_id: number | null
}

export interface SelectedTrace {
  entryId: number
  timestamp_relative_ms: number
  dst_name: string                 // Destination tensor name
  sources: SourceTensorInfo[]      // Source tensors
}

export interface TimelineState {
  currentTime: number              // Current position in timeline (ms)
  isPlaying: boolean               // Animation playing
  playbackSpeed: number            // Speed multiplier: 0.5x, 1x, 2x, 4x
}

export interface FilterState {
  selectedLayer: number | null     // Filter by layer (null = all)
  selectedCategory: string | null  // Filter by category (null = all)
  searchTerm: string               // Text search filter
}

// ============================================================================
// Buffer Timeline (from parse_buffer_stats.py) - NEW!
// ============================================================================

export interface BufferInfo {
  id: number                       // Unique buffer ID
  name: string                     // Buffer name: "KVCache_CPU", "ModelWeights_file0"
  size: number                     // Size in bytes
  backend: string                  // Backend type: "CPU", "Metal", etc.
  usage: number                    // Usage type enum value
  usage_name: string               // Usage name: "WEIGHTS", "COMPUTE", "ANY"
  layer: number                    // Associated layer (65535 = N/A)
  alloc_time_ms: number            // Allocation timestamp
  dealloc_time_ms: number | null   // Deallocation timestamp (null if still active)
}

export interface BufferTimelineEvent {
  timestamp_ms: number             // Event timestamp
  event: "alloc" | "dealloc"       // Event type
  buffer_id: number                // Buffer ID
  buffer_name: string              // Buffer name
  size: number                     // Buffer size
  cumulative_size: number          // Total allocated memory at this point
  num_active_buffers: number       // Number of active buffers
}

export interface BufferTimelineMetadata {
  total_events: number             // Total number of events
  total_buffers: number            // Total number of buffers
  peak_occupancy_bytes: number     // Peak memory occupancy
  peak_occupancy_mb: number        // Peak occupancy in MB
  duration_ms: number              // Duration of buffer tracking
  usage_breakdown: Record<string, number>  // Count by usage type
}

export interface BufferTimeline {
  metadata: BufferTimelineMetadata
  buffers: BufferInfo[]
  timeline: BufferTimelineEvent[]
}

// ============================================================================
// Correlation Index Types
// ============================================================================

export interface CorrelationIndex {
  // Address → Node mapping (for graph highlighting from trace)
  addressToNode: Map<string, GraphNode>

  // Address → Trace entries (all accesses to this tensor)
  addressToTraces: Map<string, TraceEntry[]>

  // Node ID → Memory tensor (for memory heatmap)
  nodeToMemory: Map<string, MemoryTensor>

  // Layer ID → Nodes in that layer
  layerToNodes: Map<number, GraphNode[]>

  // Time → Active nodes (for timeline animation)
  timeIndex: {
    timestamps: number[]           // Sorted timestamps (ms)
    activeNodes: string[][]        // Active node IDs at each timestamp
  }
}
