# Tensor Trace WebUI - Comprehensive Planning Document

**Version**: 1.0
**Date**: January 6, 2026
**Status**: Planning Phase
**Goal**: Build an integrated 4-view visualization tool for analyzing tensor tracing and computation graphs

---

## ğŸ“‹ Table of Contents

1. [Vision & Objectives](#vision--objectives)
2. [Architecture Overview](#architecture-overview)
3. [Data Structures](#data-structures)
4. [Technology Stack](#technology-stack)
5. [File Structure](#file-structure)
6. [Implementation Phases](#implementation-phases)
7. [Correlation Algorithms](#correlation-algorithms)
8. [Performance Considerations](#performance-considerations)
9. [UI/UX Specifications](#uiux-specifications)
10. [Testing Strategy](#testing-strategy)

---

## ğŸ¯ Vision & Objectives

### The Vision

Create a **synchronized 4-panel visualization tool** that allows researchers to:

1. **Understand computation flow** - See how data flows through the transformer
2. **Analyze memory access patterns** - Identify hot/cold memory regions in GGUF file
3. **Debug performance** - Find bottlenecks in tensor operations
4. **Correlate across views** - Click anywhere, see related data everywhere
5. **Animate execution** - Watch the computation unfold step-by-step

### Core Objectives

- âœ… **Per-token analysis** - Load and view data for individual tokens
- âœ… **Real-time correlation** - All 4 views synchronized instantly
- âœ… **Handle large data** - Gracefully handle graphs with 700+ nodes, traces with 500+ entries
- âœ… **Smooth animation** - 60fps timeline playback
- âœ… **Intuitive UX** - Click, drag, explore - no manual correlation needed

---

## ğŸ—ï¸ Architecture Overview

### Four-Panel Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Token Viewer - Token 00001                         â”‚
â”‚  [â—€ Prev]  [Token: 00001 â–¼]  [â–¶ Next]                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  VIEW 1: Computation Graph    â”‚  VIEW 2: Timeline & Trace          â”‚
â”‚  (Top-Left)                   â”‚  (Top-Right)                        â”‚
â”‚  - Interactive node/edge graphâ”‚  - Timeline slider with playback   â”‚
â”‚  - Click to select node       â”‚  - Scrollable trace table          â”‚
â”‚  - Zoom, pan controls         â”‚  - Step-by-step animation          â”‚
â”‚  - Color by layer/operation   â”‚  - Filter by layer/operation       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  VIEW 3 & 4: Memory & Architecture (Bottom, Full Width)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  VIEW 3: Memory Heatmap       â”‚  VIEW 4: 3D Transformer            â”‚
â”‚  (Bottom-Left)                â”‚  (Bottom-Right)                     â”‚
â”‚  - GGUF file memory layout    â”‚  - 3D layer visualization          â”‚
â”‚  - Heatmap of access frequencyâ”‚  - Rotate, zoom, inspect           â”‚
â”‚  - Click to see tensor detailsâ”‚  - Highlight active layer          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. RAW DATA (Generated by instrumented llama.cpp)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ /tmp/graphs/token_NNNNN.dot       (Graphviz)             â”‚
â”‚ â€¢ /tmp/tensor_trace.bin              (Binary log)          â”‚
â”‚ â€¢ model.gguf                         (Model file)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. PREPROCESSING (Python tools)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ parse_dot.py      â†’ graph-token-NNNNN.json               â”‚
â”‚ â€¢ parse_trace.py    â†’ trace-token-NNNNN.json               â”‚
â”‚ â€¢ parse_gguf.py     â†’ memory-map.json (once)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. WEB APPLICATION (React + TypeScript)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Load JSON â†’ Build Indices â†’ Render 4 Views â†’ Sync State    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. USER INTERACTION                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Click/Hover/Animate â†’ Update All Views Simultaneously       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š Data Structures

### File Naming Convention

```
BSC/tensor-tracing/data/
â”œâ”€â”€ graphs/
â”‚   â”œâ”€â”€ token-00000.json    (First token - warmup)
â”‚   â”œâ”€â”€ token-00001.json    (Second token)
â”‚   â”œâ”€â”€ token-00002.json    (Third token)
â”‚   â””â”€â”€ ...
â”œâ”€â”€ traces/
â”‚   â”œâ”€â”€ token-00000.json
â”‚   â”œâ”€â”€ token-00001.json
â”‚   â””â”€â”€ ...
â””â”€â”€ memory-map.json         (One per model)
```

### 1. Graph Data Structure

**File**: `graphs/token-NNNNN.json`

```typescript
interface GraphData {
  token_id: number
  metadata: {
    total_nodes: number
    total_edges: number
    layers: number
    timestamp_generated: string
  }
  nodes: GraphNode[]
  edges: GraphEdge[]
}

interface GraphNode {
  id: string                  // "node_0", "node_1", ...
  address: string             // "0x15001a8c0" (CORRELATION KEY)
  label: string               // "inp_embd", "Qcur-0", ...
  operation: string           // "GET_ROWS", "MUL_MAT", "ROPE", ...
  shape: number[]             // [2048, 14]
  dtype: string               // "f32", "f16", "q4_k", ...
  layer_id: number | null     // 0-21, or null for input/output
  category: string            // "input" | "attention" | "ffn" | "output"
  weight_tensor?: string      // "blk.0.attn_q.weight" (if applicable)
  position?: {x: number, y: number}  // Pre-computed layout (optional)
}

interface GraphEdge {
  source: string              // node_id
  target: string              // node_id
  label: string               // "src[0]", "src[1]", ...
}
```

**Key Design Decisions**:
- `address` is the **primary correlation key** (links to trace entries)
- Pre-categorized by `layer_id` and `category` for filtering
- `position` can be pre-computed by Python (Graphviz layout) or computed by frontend

**Estimated Size**: ~500KB per token (700 nodes Ã— ~700 bytes each)

---

### 2. Trace Data Structure

**File**: `traces/token-NNNNN.json`

```typescript
interface TraceData {
  token_id: number
  metadata: {
    total_entries: number
    duration_ms: number
    timestamp_start_ns: number
  }
  entries: TraceEntry[]
}

interface TraceEntry {
  entry_id: number                    // 0, 1, 2, ... (sequential)

  // Timing
  timestamp_ns: number                // Absolute timestamp
  timestamp_relative_ms: number       // Relative to start (for timeline)

  // Execution context
  token_id: number
  layer_id: number                    // 0-21, or 65535 for N/A
  thread_id: number
  phase: "PROMPT" | "GENERATE"

  // Operation
  operation_type: string              // "MUL_MAT", "ADD", "ROPE", ...

  // Tensor identification (CORRELATION KEYS)
  tensor_idx: number                  // Path B (efficient lookup)
  tensor_ptr: string                  // Path A: "0x15001b5b0" (PRIMARY KEY)
  tensor_name: string                 // Path A: "Qcur-0" (validation)
  size_bytes: number
  file_offset: number                 // 0 = intermediate tensor

  // Optional: Attention-specific
  attention_head?: number             // 0-127, or 255 for N/A
  qkv_type?: "Q" | "K" | "V" | "O" | "N/A"

  // Optional: MoE-specific
  expert_id?: number
  expert_rank?: number
  routing_score?: number
}
```

**Key Design Decisions**:
- `tensor_ptr` is the **primary correlation key** (links to graph nodes)
- `timestamp_relative_ms` for easy timeline slider (0 to duration_ms)
- Pre-sorted by timestamp (no need to sort in frontend)

**Estimated Size**: ~100KB per token (210 entries Ã— ~400 bytes each)

---

### 3. Memory Map Structure

**File**: `memory-map.json` (one per model, not per token)

```typescript
interface MemoryMap {
  model_name: string
  total_size_bytes: number
  metadata: {
    n_layers: number
    n_vocab: number
    n_embd: number
  }
  tensors: MemoryTensor[]
}

interface MemoryTensor {
  name: string                        // "blk.0.attn_q.weight"
  offset_start: number                // Byte offset in GGUF file
  offset_end: number                  // End offset
  size_bytes: number
  shape: number[]
  dtype: string
  category: "embedding" | "attention" | "ffn" | "output"
  layer_id: number | null
  component?: "query" | "key" | "value" | "output" | "gate" | "up" | "down"
}
```

**Key Design Decisions**:
- Contains **complete GGUF file layout**
- Used to build memory heatmap
- Can correlate `tensor_name` from trace â†’ memory region

**Estimated Size**: ~100KB total (201 tensors)

---

### 4. Correlation Index (Computed at Runtime)

**Not saved to disk** - computed by React when loading token data

```typescript
interface CorrelationIndex {
  token_id: number

  // Address â†’ Everything
  address_index: Map<string, {
    graph_node_id: string
    trace_entry_ids: number[]
    memory_tensor: string | null      // null if intermediate
    layer_id: number | null
    access_count: number
    total_time_ms: number
  }>

  // Layer â†’ Everything
  layer_index: Map<number, {
    graph_node_ids: string[]
    trace_entry_ids: number[]
    duration_ms: number
    memory_regions: string[]
  }>

  // Timeline â†’ Active elements
  timeline: Array<{
    timestamp_ms: number
    active_node: string
    active_trace_entry: number
    active_layer: number | null
  }>
}
```

**Why computed at runtime?**
- Different users may need different indices
- Easier to extend without regenerating JSON files
- Still fast (< 100ms to build for typical token)

---

## ğŸ› ï¸ Technology Stack

### Frontend

```json
{
  "framework": "React 18.3",
  "language": "TypeScript 5.3",
  "build_tool": "Vite 5.0",
  "package_manager": "npm",

  "visualization": {
    "graph": "Cytoscape.js 3.28",
    "3d": "React Three Fiber 8.15 + Three.js r160",
    "heatmap": "Canvas API (custom)",
    "charts": "Recharts 2.10 (for timeline)"
  },

  "ui": {
    "framework": "Tailwind CSS 3.4",
    "components": "Headless UI 1.7",
    "icons": "Lucide React 0.300"
  },

  "state_management": "Zustand 4.5",
  "routing": "React Router 6.21",

  "performance": {
    "virtual_scroll": "react-window 1.8",
    "memoization": "React.memo + useMemo",
    "web_workers": "Comlink 4.4"
  }
}
```

### Backend (Python Preprocessing)

```python
# Python 3.10+
dependencies = [
    "pygraphviz",      # Parse .dot files
    "struct",          # Parse binary trace
    "gguf",            # Parse GGUF files (if available)
    "json"             # Output format
]
```

### Development Tools

```json
{
  "linting": "ESLint 8.56",
  "formatting": "Prettier 3.2",
  "type_checking": "TypeScript strict mode",
  "testing": "Vitest 1.2 + React Testing Library"
}
```

---

## ğŸ“ File Structure

```
BSC/tensor-tracing/
â”œâ”€â”€ WEBUI.md                          # This document
â”œâ”€â”€ README.md                         # Quick start guide
â”‚
â”œâ”€â”€ tools/                            # Python preprocessing
â”‚   â”œâ”€â”€ parse_dot.py                  # .dot â†’ JSON
â”‚   â”œâ”€â”€ parse_trace.py                # binary â†’ JSON (enhance existing)
â”‚   â”œâ”€â”€ parse_gguf.py                 # GGUF â†’ memory-map.json
â”‚   â””â”€â”€ preprocess_all.py             # Run all parsers
â”‚
â”œâ”€â”€ data/                             # Generated JSON files
â”‚   â”œâ”€â”€ graphs/
â”‚   â”‚   â”œâ”€â”€ token-00000.json
â”‚   â”‚   â””â”€â”€ token-00001.json
â”‚   â”œâ”€â”€ traces/
â”‚   â”‚   â”œâ”€â”€ token-00000.json
â”‚   â”‚   â””â”€â”€ token-00001.json
â”‚   â””â”€â”€ memory-map.json
â”‚
â””â”€â”€ webui/                            # React application
    â”œâ”€â”€ package.json
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ vite.config.ts
    â”œâ”€â”€ index.html
    â”‚
    â”œâ”€â”€ public/                       # Static assets
    â”‚   â””â”€â”€ favicon.svg
    â”‚
    â””â”€â”€ src/
        â”œâ”€â”€ main.tsx                  # App entry point
        â”œâ”€â”€ App.tsx                   # Root component
        â”‚
        â”œâ”€â”€ types/                    # TypeScript definitions
        â”‚   â”œâ”€â”€ graph.ts
        â”‚   â”œâ”€â”€ trace.ts
        â”‚   â”œâ”€â”€ memory.ts
        â”‚   â””â”€â”€ correlation.ts
        â”‚
        â”œâ”€â”€ stores/                   # Zustand state
        â”‚   â”œâ”€â”€ viewerStore.ts        # Global state
        â”‚   â””â”€â”€ correlationStore.ts   # Correlation indices
        â”‚
        â”œâ”€â”€ components/               # React components
        â”‚   â”œâ”€â”€ Layout/
        â”‚   â”‚   â”œâ”€â”€ AppLayout.tsx     # 4-panel layout
        â”‚   â”‚   â””â”€â”€ TokenSelector.tsx # Token navigation
        â”‚   â”‚
        â”‚   â”œâ”€â”€ GraphView/            # View 1
        â”‚   â”‚   â”œâ”€â”€ GraphView.tsx
        â”‚   â”‚   â”œâ”€â”€ GraphCanvas.tsx   # Cytoscape wrapper
        â”‚   â”‚   â””â”€â”€ GraphControls.tsx # Zoom, filter, etc.
        â”‚   â”‚
        â”‚   â”œâ”€â”€ TraceView/            # View 2
        â”‚   â”‚   â”œâ”€â”€ TraceView.tsx
        â”‚   â”‚   â”œâ”€â”€ Timeline.tsx      # Slider + play controls
        â”‚   â”‚   â””â”€â”€ TraceTable.tsx    # Virtual scrolling table
        â”‚   â”‚
        â”‚   â”œâ”€â”€ MemoryView/           # View 3
        â”‚   â”‚   â”œâ”€â”€ MemoryView.tsx
        â”‚   â”‚   â”œâ”€â”€ HeatmapCanvas.tsx # Canvas-based heatmap
        â”‚   â”‚   â””â”€â”€ MemoryDetails.tsx # Hover details
        â”‚   â”‚
        â”‚   â””â”€â”€ ArchView/             # View 4
        â”‚       â”œâ”€â”€ ArchView.tsx
        â”‚       â””â”€â”€ TransformerModel.tsx # Three.js 3D model
        â”‚
        â”œâ”€â”€ utils/                    # Utilities
        â”‚   â”œâ”€â”€ dataLoader.ts         # Load JSON files
        â”‚   â”œâ”€â”€ correlationBuilder.ts # Build indices
        â”‚   â””â”€â”€ formatters.ts         # Format data for display
        â”‚
        â””â”€â”€ styles/
            â””â”€â”€ globals.css           # Tailwind + custom styles
```

---

## ğŸ—ï¸ Implementation Phases

### Phase 0: Setup & Preprocessing (Week 1)

**Goal**: Get data pipeline working

**Tasks**:
1. âœ… Create `tools/parse_dot.py`
   - Parse `.dot` files using pygraphviz
   - Extract nodes, edges, labels, shapes
   - Output `graph-token-NNNNN.json`
   - Estimated: 100 lines of Python

2. âœ… Enhance `tools/parse_trace.py`
   - Add `--token N` flag to filter by token
   - Add `--format json` flag
   - Output `trace-token-NNNNN.json`
   - Estimated: +50 lines to existing script

3. âœ… Create `tools/parse_gguf.py`
   - Extract tensor metadata from GGUF file
   - Build memory layout map
   - Output `memory-map.json`
   - Estimated: 150 lines of Python

4. âœ… Create `tools/preprocess_all.py`
   - Run all parsers in sequence
   - Usage: `python preprocess_all.py --graphs /tmp/graphs --trace /tmp/tensor_trace.bin --gguf model.gguf`
   - Estimated: 50 lines

**Deliverable**: Can run preprocessing and get clean JSON files âœ…

---

### Phase 1: React Setup & View 1 (Week 2)

**Goal**: Get graph viewer working with basic interaction

**Tasks**:
1. âœ… Initialize React project
   ```bash
   cd BSC/tensor-tracing/webui
   npm create vite@latest . -- --template react-ts
   npm install
   ```

2. âœ… Install dependencies
   ```bash
   npm install zustand react-router-dom
   npm install cytoscape @types/cytoscape
   npm install tailwindcss postcss autoprefixer
   npm install lucide-react
   ```

3. âœ… Set up project structure
   - Create all folders in `src/`
   - Set up Tailwind CSS
   - Create TypeScript types

4. âœ… Implement data loading
   - `utils/dataLoader.ts` - fetch JSON files
   - Error handling for missing files

5. âœ… Build View 1: Graph Viewer
   - `GraphView.tsx` - container
   - `GraphCanvas.tsx` - Cytoscape integration
   - Basic layout: cola, dagre, or breadthfirst
   - Click node â†’ log to console
   - Zoom, pan controls

6. âœ… Add token selector
   - Dropdown to select token ID
   - Load corresponding graph JSON

**Deliverable**: Can view graph for any token, click nodes, zoom/pan âœ…

---

### Phase 2: View 2 - Timeline & Trace (Week 3)

**Goal**: Add trace table and timeline slider

**Tasks**:
1. âœ… Load trace data
   - Fetch `trace-token-NNNNN.json`
   - Store in Zustand state

2. âœ… Build Timeline component
   - Slider from 0 to duration_ms
   - Play/pause/reset buttons
   - Speed controls (1x, 2x, 5x)
   - Current time display

3. âœ… Build TraceTable component
   - Virtual scrolling (react-window)
   - Columns: Time, Operation, Tensor, Layer
   - Click row â†’ highlight in graph

4. âœ… Implement basic correlation
   - When timeline slider moves:
     - Find corresponding trace entry
     - Get `tensor_ptr` from entry
     - Find graph node with matching address
     - Highlight that node in graph

**Deliverable**: Can scrub timeline, see trace entries, basic highlighting âœ…

---

### Phase 3: View 3 - Memory Heatmap (Week 4)

**Goal**: Visualize memory access patterns

**Tasks**:
1. âœ… Load memory map
   - Fetch `memory-map.json` (once)
   - Build layout blocks

2. âœ… Build HeatmapCanvas component
   - Canvas-based rendering
   - Draw rectangles for each tensor
   - Color by access frequency (from trace data)
   - Gradient: blue (0 accesses) â†’ red (100+ accesses)

3. âœ… Add interactivity
   - Hover over block â†’ show tooltip (tensor name, size, access count)
   - Click block â†’ filter trace table to show only accesses to that tensor
   - Zoom/pan for large models

4. âœ… Correlation
   - When graph node selected â†’ highlight memory block
   - When timeline scrubbing â†’ highlight block being accessed

**Deliverable**: Can see which memory regions are hot/cold âœ…

---

### Phase 4: View 4 - 3D Transformer (Week 5)

**Goal**: Beautiful 3D architectural visualization

**Tasks**:
1. âœ… Set up Three.js
   ```bash
   npm install three @react-three/fiber @react-three/drei
   ```

2. âœ… Build TransformerModel component
   - Create 3D boxes for:
     - Input embedding
     - Each layer (22 boxes stacked vertically)
     - Each layer subdivided: Attention + FFN
     - Output layer
   - Basic lighting, camera, controls

3. âœ… Add interactivity
   - Orbit controls (rotate, zoom)
   - Click layer â†’ filter graph/trace to that layer
   - Hover layer â†’ show tooltip (layer ID, node count)

4. âœ… Correlation
   - When timeline playing â†’ highlight active layer
   - When graph node selected â†’ highlight corresponding layer
   - Pulsing animation for active layer

**Deliverable**: Can rotate 3D model, click layers, see execution flow âœ…

---

### Phase 5: Animation & Polish (Week 6)

**Goal**: Make it smooth and production-ready

**Tasks**:
1. âœ… Timeline animation
   - Play button â†’ auto-increment timeline slider
   - Smooth 60fps animation
   - Step-by-step mode (advance one trace entry at a time)

2. âœ… Advanced correlation
   - Build `CorrelationIndex` when loading token
   - Instant lookups for all correlations
   - Sync all 4 views on every interaction

3. âœ… Performance optimization
   - Memoize expensive computations
   - Debounce hover events
   - Lazy load token data (only load when selected)

4. âœ… UI polish
   - Loading states
   - Error boundaries
   - Keyboard shortcuts (space = play/pause, arrow keys = step)
   - Export screenshot

5. âœ… Documentation
   - Update README.md with screenshots
   - Add inline code comments
   - Create usage guide

**Deliverable**: Production-ready tool âœ…

---

## ğŸ”— Correlation Algorithms

### 1. Address-Based Correlation (Primary)

**Use case**: Link graph nodes â†” trace entries â†” memory regions

**Algorithm**:
```typescript
// Build index when loading token
function buildAddressIndex(
  graphNodes: GraphNode[],
  traceEntries: TraceEntry[],
  memoryTensors: MemoryTensor[]
): Map<string, CorrelationData> {

  const index = new Map<string, CorrelationData>()

  // Index graph nodes by address
  for (const node of graphNodes) {
    if (!index.has(node.address)) {
      index.set(node.address, {
        graph_node_id: node.id,
        trace_entry_ids: [],
        memory_tensor: null,
        layer_id: node.layer_id,
        access_count: 0,
        total_time_ms: 0
      })
    }
  }

  // Add trace entries
  for (const entry of traceEntries) {
    const data = index.get(entry.tensor_ptr)
    if (data) {
      data.trace_entry_ids.push(entry.entry_id)
      data.access_count++
      // Compute time delta (next entry - this entry)
      // Add to total_time_ms
    }
  }

  // Link to memory tensors (for weight tensors only)
  for (const node of graphNodes) {
    if (node.weight_tensor) {
      const memTensor = memoryTensors.find(t => t.name === node.weight_tensor)
      if (memTensor) {
        const data = index.get(node.address)
        if (data) {
          data.memory_tensor = memTensor.name
        }
      }
    }
  }

  return index
}
```

**Complexity**: O(N + M + T) where N = nodes, M = trace entries, T = memory tensors
**Performance**: < 50ms for typical token

---

### 2. Layer-Based Correlation

**Use case**: Filter all views by layer

**Algorithm**:
```typescript
function buildLayerIndex(
  graphNodes: GraphNode[],
  traceEntries: TraceEntry[]
): Map<number, LayerData> {

  const index = new Map<number, LayerData>()

  // Group by layer
  for (const node of graphNodes) {
    if (node.layer_id !== null) {
      if (!index.has(node.layer_id)) {
        index.set(node.layer_id, {
          graph_node_ids: [],
          trace_entry_ids: [],
          duration_ms: 0,
          memory_regions: new Set()
        })
      }
      const data = index.get(node.layer_id)!
      data.graph_node_ids.push(node.id)
      if (node.weight_tensor) {
        data.memory_regions.add(node.weight_tensor)
      }
    }
  }

  // Add trace entries
  for (const entry of traceEntries) {
    if (entry.layer_id !== 65535) {  // 65535 = N/A
      const data = index.get(entry.layer_id)
      if (data) {
        data.trace_entry_ids.push(entry.entry_id)
      }
    }
  }

  // Compute duration per layer
  for (const [layerId, data] of index.entries()) {
    const entries = data.trace_entry_ids.map(id => traceEntries[id])
    if (entries.length > 0) {
      const firstTime = entries[0].timestamp_relative_ms
      const lastTime = entries[entries.length - 1].timestamp_relative_ms
      data.duration_ms = lastTime - firstTime
    }
  }

  return index
}
```

---

### 3. Timeline-Based Correlation

**Use case**: Scrub timeline, highlight active nodes

**Algorithm**:
```typescript
function getActiveElementsAtTime(
  timestamp_ms: number,
  traceEntries: TraceEntry[],
  addressIndex: Map<string, CorrelationData>
): {
  activeNode: string | null
  activeTraceEntry: number | null
  activeLayer: number | null
} {

  // Binary search to find closest trace entry
  let left = 0, right = traceEntries.length - 1
  let closest = 0

  while (left <= right) {
    const mid = Math.floor((left + right) / 2)
    if (traceEntries[mid].timestamp_relative_ms <= timestamp_ms) {
      closest = mid
      left = mid + 1
    } else {
      right = mid - 1
    }
  }

  const entry = traceEntries[closest]
  const correlationData = addressIndex.get(entry.tensor_ptr)

  return {
    activeNode: correlationData?.graph_node_id || null,
    activeTraceEntry: entry.entry_id,
    activeLayer: entry.layer_id !== 65535 ? entry.layer_id : null
  }
}
```

**Complexity**: O(log M) where M = trace entries (binary search)
**Performance**: < 1ms (instant)

---

## âš¡ Performance Considerations

### 1. Data Loading

**Challenge**: Loading 10+ tokens Ã— 600KB each = 6MB total

**Solutions**:
- âœ… **Lazy loading**: Only load selected token's data
- âœ… **Caching**: Keep last 3 tokens in memory
- âœ… **Preloading**: Load next token in background while viewing current

**Implementation**:
```typescript
const tokenCache = new Map<number, TokenData>()
const CACHE_SIZE = 3

async function loadToken(tokenId: number): Promise<TokenData> {
  // Check cache
  if (tokenCache.has(tokenId)) {
    return tokenCache.get(tokenId)!
  }

  // Load from files
  const [graph, trace] = await Promise.all([
    fetch(`/data/graphs/token-${tokenId.toString().padStart(5, '0')}.json`),
    fetch(`/data/traces/token-${tokenId.toString().padStart(5, '0')}.json`)
  ])

  const tokenData = {
    graph: await graph.json(),
    trace: await trace.json()
  }

  // Add to cache
  tokenCache.set(tokenId, tokenData)

  // Evict oldest if cache full
  if (tokenCache.size > CACHE_SIZE) {
    const oldestKey = tokenCache.keys().next().value
    tokenCache.delete(oldestKey)
  }

  return tokenData
}
```

---

### 2. Graph Rendering

**Challenge**: 700 nodes + 1234 edges = potentially slow

**Solutions**:
- âœ… **Cytoscape optimizations**: Use `headless: false`, enable `wheelSensitivity`
- âœ… **Level-of-detail**: Hide edge labels when zoomed out
- âœ… **Progressive rendering**: Render visible nodes first

**Implementation**:
```typescript
const cytoscapeOptions = {
  wheelSensitivity: 0.1,
  maxZoom: 3,
  minZoom: 0.1,

  // Hide labels when zoomed out
  style: [
    {
      selector: 'node',
      style: {
        'label': (ele) => {
          const zoom = ele.cy().zoom()
          return zoom > 0.5 ? ele.data('label') : ''
        }
      }
    }
  ]
}
```

---

### 3. Trace Table Rendering

**Challenge**: 500+ rows = slow DOM rendering

**Solutions**:
- âœ… **Virtual scrolling**: Only render visible rows (react-window)
- âœ… **Memoization**: Use `React.memo` for row components

**Implementation**:
```tsx
import { FixedSizeList } from 'react-window'

function TraceTable({ entries }: { entries: TraceEntry[] }) {
  const Row = React.memo(({ index, style }: { index: number, style: any }) => {
    const entry = entries[index]
    return (
      <div style={style}>
        {entry.timestamp_relative_ms.toFixed(2)}ms | {entry.operation_type} | {entry.tensor_name}
      </div>
    )
  })

  return (
    <FixedSizeList
      height={600}
      itemCount={entries.length}
      itemSize={30}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  )
}
```

---

### 4. Heatmap Rendering

**Challenge**: Drawing 201 rectangles Ã— 60fps = expensive

**Solutions**:
- âœ… **Canvas API**: Direct pixel manipulation (faster than SVG/DOM)
- âœ… **Dirty rectangles**: Only redraw changed regions
- âœ… **Debounced hover**: Update tooltip only every 16ms (60fps)

**Implementation**:
```typescript
// Only redraw when data changes or zoom/pan
useEffect(() => {
  const canvas = canvasRef.current
  const ctx = canvas.getContext('2d')

  // Clear
  ctx.clearRect(0, 0, canvas.width, canvas.height)

  // Draw each tensor block
  for (const tensor of memoryTensors) {
    const x = (tensor.offset_start / totalSize) * canvas.width
    const width = (tensor.size_bytes / totalSize) * canvas.width
    const height = 40

    // Color by access count
    const accessCount = getAccessCount(tensor.name)
    const color = getHeatColor(accessCount)

    ctx.fillStyle = color
    ctx.fillRect(x, 0, width, height)
  }
}, [memoryTensors, accessCounts, zoom])
```

---

### 5. 3D Rendering

**Challenge**: 22 layers Ã— multiple meshes = potential lag

**Solutions**:
- âœ… **Instanced rendering**: Reuse geometries
- âœ… **LOD**: Simplify geometry when camera far away
- âœ… **Frustum culling**: Don't render off-screen objects

**Implementation**:
```tsx
import { useFrame } from '@react-three/fiber'

function TransformerModel() {
  // Reuse geometry for all layers
  const boxGeometry = useMemo(() => new THREE.BoxGeometry(1, 0.2, 1), [])

  return (
    <>
      {Array.from({ length: 22 }).map((_, i) => (
        <mesh key={i} geometry={boxGeometry} position={[0, i * 0.3, 0]}>
          <meshStandardMaterial color={i === activeLayer ? 'red' : 'blue'} />
        </mesh>
      ))}
    </>
  )
}
```

---

## ğŸ¨ UI/UX Specifications

### Color Scheme

**Graph Nodes** (by category):
- ğŸ”µ Input: `#3B82F6` (blue)
- ğŸŸ¢ Attention: `#10B981` (green)
- ğŸŸ¡ FFN: `#F59E0B` (amber)
- ğŸ”´ Output: `#EF4444` (red)
- âšª Other: `#6B7280` (gray)

**Graph Nodes** (by state):
- Active: `#22C55E` (bright green) + glow
- Selected: `#3B82F6` (blue) + thick border
- Past: `#9CA3AF` (gray, dimmed)
- Future: `#D1D5DB` (light gray, very dim)

**Heatmap** (access frequency):
```typescript
function getHeatColor(accessCount: number): string {
  if (accessCount === 0) return '#1E3A8A'      // Dark blue (cold)
  if (accessCount < 10) return '#3B82F6'       // Blue
  if (accessCount < 50) return '#F59E0B'       // Amber
  if (accessCount < 100) return '#F97316'      // Orange
  return '#DC2626'                             // Red (hot)
}
```

**3D Model**:
- Inactive layer: `#3B82F6` (blue)
- Active layer: `#EF4444` (red) + pulsing
- Hovered layer: `#F59E0B` (amber)

---

### Layout & Spacing

```css
/* 4-panel grid */
.app-layout {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 1rem;
  height: 100vh;
  padding: 1rem;
}

/* Top panels (graph + trace) */
.view-graph { grid-area: 1 / 1 / 2 / 2; }
.view-trace { grid-area: 1 / 2 / 2 / 3; }

/* Bottom panels (memory + 3D) */
.view-memory { grid-area: 2 / 1 / 3 / 2; }
.view-3d { grid-area: 2 / 2 / 3 / 3; }
```

---

### Keyboard Shortcuts

| Key | Action |
|-----|--------|
| `Space` | Play/Pause timeline |
| `â†’` | Step forward (next trace entry) |
| `â†` | Step backward (previous trace entry) |
| `Home` | Jump to start |
| `End` | Jump to end |
| `1-4` | Focus on View 1-4 |
| `F` | Fit graph to view |
| `Esc` | Clear selection |

---

## ğŸ§ª Testing Strategy

### Unit Tests

```typescript
// Test correlation builder
describe('buildAddressIndex', () => {
  it('should link graph nodes to trace entries by address', () => {
    const nodes = [{ id: 'node_1', address: '0xABC' }]
    const entries = [{ entry_id: 0, tensor_ptr: '0xABC' }]
    const index = buildAddressIndex(nodes, entries, [])

    expect(index.get('0xABC')?.graph_node_id).toBe('node_1')
    expect(index.get('0xABC')?.trace_entry_ids).toEqual([0])
  })
})

// Test timeline lookup
describe('getActiveElementsAtTime', () => {
  it('should find correct trace entry for timestamp', () => {
    const entries = [
      { entry_id: 0, timestamp_relative_ms: 0.0 },
      { entry_id: 1, timestamp_relative_ms: 1.2 },
      { entry_id: 2, timestamp_relative_ms: 2.5 }
    ]

    const result = getActiveElementsAtTime(1.5, entries, new Map())
    expect(result.activeTraceEntry).toBe(1)
  })
})
```

### Integration Tests

```typescript
// Test full correlation flow
describe('View synchronization', () => {
  it('should update all views when timeline changes', async () => {
    render(<App />)

    // Load token
    await selectToken(1)

    // Move timeline
    const slider = screen.getByRole('slider')
    fireEvent.change(slider, { target: { value: 1.2 } })

    // Check all views updated
    expect(graphView).toHaveActiveNode('node_1')
    expect(traceView).toHaveSelectedEntry(0)
    expect(memoryView).toHaveHighlightedRegion('blk.0.attn_q.weight')
    expect(archView).toHaveActiveLayer(0)
  })
})
```

### Manual Testing Checklist

- [ ] Can load token data without errors
- [ ] Graph renders all nodes and edges
- [ ] Can zoom/pan graph
- [ ] Click node â†’ highlights in trace
- [ ] Click trace entry â†’ highlights in graph
- [ ] Timeline slider works smoothly
- [ ] Play button animates timeline
- [ ] Heatmap shows correct colors
- [ ] Hover heatmap â†’ shows tooltip
- [ ] 3D model renders
- [ ] Can rotate 3D model
- [ ] Click layer â†’ filters other views
- [ ] All 4 views stay synchronized
- [ ] Keyboard shortcuts work
- [ ] No console errors

---

## ğŸ“ Next Steps

### Immediate Actions

1. âœ… **Review this document** - Make sure vision is clear
2. â³ **Set up Python tools** - Implement preprocessing pipeline
3. â³ **Initialize React project** - Get basic structure running
4. â³ **Implement Phase 1** - Graph viewer first

### Long-term Roadmap

- **Week 1**: Preprocessing tools working
- **Week 2**: Graph viewer complete
- **Week 3**: Timeline + trace viewer complete
- **Week 4**: Memory heatmap complete
- **Week 5**: 3D transformer complete
- **Week 6**: Polish and optimize

---

## ğŸ“š References

- [Cytoscape.js Documentation](https://js.cytoscape.org/)
- [React Three Fiber Docs](https://docs.pmnd.rs/react-three-fiber)
- [Zustand Guide](https://zustand-demo.pmnd.rs/)
- [Vite Documentation](https://vitejs.dev/)

---

**End of Planning Document**
